# JavaScript

<img src="img/logo/js_logo.png" alt="js_logo" style="zoom:25%;" />

## **JS 中的数据类型**

JavaScript 是弱类型语言，使用 `var `定义任意变量。可通过 `typeof` 关键字来获取 JS 中变量的数据类型。

6 种不同的数据类型：`string`，`number`，`boolean`，`object`，`function`，`symbol`

3 种对象类型：`Object`，`Date`，`Array`

2 种特殊类型：`null`，`undefined`

```javascript
typeof "xiao";//返回string
typeof 3.14;//返回number
typeof NaN;//返回number
typeof false;//返回boolean
typeof [1,2,3,4];//返回object
typeof {name:"xiao",age:24};//返回object
typeof new Date();//返回object
typeof function() {};//返回function;
typeof person;//返回undefined（person没有赋值）
typeof null;//返回object
```

注意：在 JS 中，数组是一种特殊的对象类型。 `typeof()` 不能用来判断 `Array` 和`Object`。

可以使用以下方法判断：

1、使用 `isArray()` 方法

```javascript
var arr = [];
if(Array.isArray(arr)) {
	console.log("该变量引用一个数组");
}
```

2、使用 `instanceof` 操作符

```javascript
var arr = [];
if(arr instanceof Array) {
	console.log("该变量引用一个数组");
}
```

### 特殊数据类型

#### null

`null` 是一个只有一个值的特殊类型，表示一个空对象引用。

可以将变量的值设置为 `null` 来释放引用的对象：

```javascript
var person = {name:"xiao",age:24};
person = null;
```

#### undefined

`undefined` 是所有没有赋值的变量的默认值。

```javascript
var person;
typeof person;//返回undefined
```

同样也可以将变量的值设为 `undefined` 来清空。

```javascript
person = undefined;//值为undefined，类型为undefined
```

`null` 和 `undefined` 的值相等，但类型不等：

```javascript
typeof undefined;//undefined
typeof null;//object
null === undefined;//false
null == undefined;//true
```

#### NaN

`Number.NaN` 是一个特殊值，说明某些算术运算（如求负数的平方根）的结果不是数字。方法 `parseInt()` 和 `parseFloat()` 在不能解析指定的字符串时就返回这个值。JS 以 `NaN`的形式输出 `Number.NaN`。`NaN` 与其他数值进行比较的结果总是不相等的，包括它自身在内。因此，不能与 `Number.NaN` 比较来检测一个值是不是数字，而只能调用 `isNaN()` 判断一个值是否为 `NaN`。

## JS 中的逻辑运算

在 JS 中，**truthy**（真值）指的是在布尔值上下文中，转换后的值为真的值。除 `false`、`0`、`""`、`null`、`undefined` 和 `NaN` 以外都是真值。

#### 1、取反 ！

首先把数据转化为布尔值，然后取反，结果为 `true` 或 `false`。

```javascript
console.log(!0);//true
console.log(!10);//false
```

#### 2、逻辑与 &&

如果第一个操作数能够转为 `true`，计算结果就是第二个操作数；如果第一个操作数能够转为 `false`，结果就是第一个操作数。

```javascript
console.log(true && 10);//第两个操作数均可转换为true，结果是第二个操作数，也就是10
console.log(false && 10);//第一个操作数是false，结果flase
console.log(10 && false);//第二个操作数是false，结果flase
console.log(undefined && false);//第一个操作数是undefined，结果undefined
console.log(NaN && false);//第一个操作数是NaN，结果NaN
console.log(null && false);//第一个操作数是null，结果null
console.log('' && false);//第一个操作数是空串，结果空串
console.log(0 && 100);//第一个操作数是0，结果是0
```

#### 3、逻辑或 ||

如果第一个操作数能够转为 `true`，结果就是第一个操作数，否则结果是第二个操作数。

```javascript
console.log(true || 10);//第一个操作数是true，结果是第一个操作，也就是true
console.log(false || 10);//第一个操作数是false，结果是第二个操作数10
console.log(10 || false);//第一个操作数是10，结果10
console.log(undefined || 10);//第一个操作数是undefined转false，结果10
console.log(NaN || 10);//第一个操作数是NaN转false，结果10
console.log(null || 10);//第一个操作数是null转false，结果10
console.log('' || 10);//第一个操作数是空串转false，结果10
console.log(0 || 10); //第一个操作数是0转false,结果是10
```

## JS 中的循环语句

### for in 

```javascript
let obj = {'name':'xiao','age':20};
for(let index in obj){
	console.log(index,obj[index]);
}
```

其中 `index` 代表对象的 `key` 值，`obj[index]` 代表对应的 `value` 值。

### for of 

```javascript
let obj = [1,2,3];
for(let item of obj){
	console.log(item);
}
```

用于遍历 `Array(数组)`、`String(字符串)` 等可迭代的数据结构。

# jQuery

<img src="img/logo/jquery_logo.png" alt="jquery_logo" style="zoom: 25%;" />

## HTML 元素选取

### 元素选择器

基于 HTML 元素名选取元素。

```javascript
$("p")//选取页面中所有<p>元素
```

### #id选择器

通过 HTML 元素的 `id` 属性选取元素。

```javascript
$("#test")//选取页面中id为"test"的元素
```

### .class选择器

通过 HTML 元素的 `class` 属性选取元素。

```javascript
$(".test")//选取页面中class为"test"的元素
```

## HTML 事件

**事件方法语法**

定义点击事件：

```javascript
$("p").click(function(){
	//动作触发后执行的代码
    ...
});
```

### **$(document).ready()**

文档就绪事件，在 HTML 所有标签加载完成后会触发该函数。

### **click()**

点击事件，当用户点击 HTML 元素时会触发该函数。

### **hover()**

光标悬停事件，当光标移动到 HTML 元素上时，会触发指定的第一个函数；当光标移出这个元素时，会触发指定的第二个函数。

```javascript
$("#test").hover(
    function(){
        //动作触发后执行的代码
    },
    function(){
    
    }
);
```

### **focus()**

获得焦点事件，当通过鼠标点击选中 HTML 元素或通过 Tab 键定位到元素时，该元素就会获得焦点，触发该函数。

### **blur()**

失去焦点事件，当 HTML 元素失去焦点时触发该函数。

## HTML DOM 遍历和修改

### 获取/设置内容

**text()** 	返回或设置所选元素的文本内容。

**html()** 	返回或设置所选元素的内容（包括 HTML 标记）。

**val()** 	返回或设置表单字段的值。

### 获取/设置属性

**attr()** 方法用于获取或设置属性值。

```javascript
$("#test").attr("href");//获取当前页面id为"test"的元素的href属性的值
```

```javascript
$("#test").attr("href","www.baidu.com");//设置当前页面id为"test"的元素的href属性的值为"www.baidu.com"
```

```javascript
$("#test").attr({
	"href" : "www.baidu.com",
	"title" : "jQuery 教程"
});//同时设置多个属性
```

### 添加元素/内容

#### **添加新的 HTML 内容**

**append()** 	在被选元素内部的结尾插入内容。

```javascript
$("test").append("追加文本");
```

**prepend()** 	在被选元素内部的开头插入内容。

**after()** 	在被选元素之后插入内容。

**before()** 	在被选元素之前插入内容。

#### **添加新的 HTML 元素**

上面的方法都能够通过参数接收不限数量的新元素。可以通过 text/HTML、JS/DOM 或jQuery 来创建新元素，然后通过上面的方法将新元素添加到当前页面中。

```javascript
function appendTest(){
	var txt1 = "<p>文本1</p>";//使用HTML标签创建元素
	var txt2 = $("<P></P>").text("文本2");//使用jQuery创建元素
	var txt3 = document.createElement("p");
	txt3.innerHTML = "文本3";//使用DOM创建元素
	$("body").append(txt1,txt2,txt3);//追加新元素
}
```

### 删除元素

**remove()** 	删除被选元素（及其子元素）。

```javascript
$("#test").remove();
```

`remove()` 方法也可以接受一个参数，允许对被删元素进行过滤。

```javascript
$("p").remove(".italic");//删除class为"italic"的所有<p>元素
```

**empty()** 	删除被选元素的子元素

### 获取并设置css类

**addClass()** 	向被选元素添加一个或多个 `class` 属性。

```javascript
$("h1,h2,p").addClass("test");//一次选取多个元素
```

```javascript
$("p").addClass("test testPro");//一次添加多个类
```

**removeClass()** 	从被选元素删除一个或多个 `class` 属性。

**toggleClass()** 	对被选元素进行添加/删除 `class` 属性的切换操作。

**css()** 	设置或返回被选元素样式属性。

返回 CSS 属性：

```javascript
$("p").css("background-color");//返回首个<p>的background-color的值
```

设置 CSS 属性：

```javascript
$("p").css("background-color","yellow");//将所有<p>的background-color值设置为"yellow"
```

设置多个 CSS 属性：

```javascript
$("p").css({"background-color":"yellow","font-size":"200%"});
```

### 遍历

根据其他元素的关系来查找或选取 HTML 元素。

#### 向上遍历 DOM 树

**parent()**

返回被选元素的直接父元素，该方法只会向上一级对 DOM 树进行遍历。

**parents()**

返回被选元素的所有祖先元素，一路向上直到文档的根目录(\<html>)。

也可使用可选参数来过滤对祖先元素的搜索。

```javascript
$("span").parents("ul");//返回<span>的所有祖先元素，并且是<ul>元素
```

#### 向下遍历 DOM 树

**children()**

返回被选元素的所有直接子元素，该方法只会向下一级对 DOM 树进行遍历。

也可使用可选参数来过滤对子元素的搜索。

```javascript
$("div").children("p.test");//返回class属性为test的所有<p>元素,并且它们是<div>的直接子元素
```

**find()**

返回被选元素的所有后代元素，一路向下直到最后一个后代元素。

```javascript
$("div").find("*");//返回<div>的所有后代元素
```

#### 水平遍历DOM树

**siblings()**

返回被选元素的所有同胞元素（同胞元素有相同的父元素）。也可以使用可选参数来过滤对同胞元素的搜索。

**next() / prev()**

返回被选元素的下 / 上一个同胞元素。

**nextAll() / prevAll()**

返回被选元素之后 / 前的所有同胞元素。

### 过滤

**first()**

返回被选元素的首个元素。

```javascript
$("div p").first();//返回首个<div>元素内部的第一个<p>元素
```

**last()**

返回被选元素的最后一个元素。

**eq()**

返回被选元素中带有指定索引号的元素，索引号从 0 开始。

```javascript
$("p").eq(1);//返回当前页面的第二个<p>元素
```

**filter() / not()**

该方法允许用户规定一个标准，返回匹配 / 不匹配这个标准的元素。

```javascript
$("p").filter(".test");//返回class属性为"test"的所有<p>元素
```

## AJAX

> AJAX = 异步 JavaScript 和 XML（Asynchronous JavaScript and XML）。在不重载整个网页的情况下，AJAX 通过后台加载数据，并在网页上进行显示。

**load()**

该方法从服务器加载数据，并把返回的数据放入被选元素中。

```javascript
$(selector).load(URL,data,callback);
```

* URL：必需，规定希望加载的URL
* data：可选，规定与请求一同发送的查询字符串键值对集合
* callback：可选，load()方法完成后所执行的函数

**$.get()**

该方法通过 HTTP GET 请求从服务器上请求数据。

```javascript
$.get(URL,callback);
```

* URL：必需，规定希望请求的URL
* callback：可选，请求成功后所执行的函数

**$.post()**

该方法通过 HTTP POST 请求向服务器提交数据。

```javascript
$.post(URL,data,callback);
```

* URL：必需，规定希望请求的URL
* data：可选，规定连请求发送的数据
* callback：可选，请求成功后所执行的函数

## Q&A

### jQuery入口函数与JavaScript入口函数的区别

jQuery 入口函数：

```javascript
$(document).ready(function(){
	//执行代码
})
或者
$(function(){
	//执行代码
})
```

JavaScript 入口函数：

```javascript
window.onload = function(){
	//执行代码
}
```

jQuery 入口函数与 JavaScript 入口函数的区别：

* jQuery 的入口函数是在 HTML 所有标签(DOM)加载完成后执行。
* JavaScript 的 `window.onload` 事件是等到所有内容，包括外部图片之类的文件加载完成后才会执行。

# Node.js

<img src="img/logo/nodejs_logo.png" alt="nodejs_logo" style="zoom: 50%;" />

## 安装和配置

安装完成Node.js后，输入以下命令验证安装：

```shell
node -v  # 显示安装的Node.js版本
npm -v  # 显示安装的npm版本
```

### 修改全局模块下载路径

在Node.js安装目录下，新建文件夹 node_global 和 node_cache。

然后输入以下命令：

```shell
# 创建的node_global文件夹所在路径
npm config set prefix "D:\DevTools\nodejs\node_global"
# 创建的node_cache文件夹所在路径
npm config set cache "D:\DevTools\nodejs\node_cache"
```

### 配置系统环境变量

在【系统变量】下新建【NODE_PATH】输入【D:\DevTools\nodejs\node_global\node_modules】。

在【系统变量】下编辑【Path】，添加【D:\DevTools\nodejs\node_global】。

这样 Node.js 下载的模块就会自动下载到自定义目录。

输入以下命令验证：

```shell
npm install express -g
```

在自定义目录找到 express 模块，说明配置成功。

### 更换nmp源为淘宝镜像

1、查看当前npm源：

```shell
npm config get registry
```

2、更换源为淘宝镜像：

```shell
npm config set registry https://registry.npm.taobao.org/
```

### 全局安装基于淘宝源的cnpm

> 由于npm的服务器在海外，访问速度比较慢且不稳定 ，cnpm的服务器是由淘宝团队提供，服务器在国内，cnpm是npm镜像，一般会同步更新，所以cnpm在安装一些软件时候会比较有优势。但是一般cnpm只用于安装，在项目创建与卸载等相关操作时候还是使用npm。

全局安装基于淘宝源的cnpm：

```shell
npm install -g cnpm --registry=https://registry.npm.taobao.org
```

验证是否安装成功：

````shell
cnpm -v
````

# 遇到的 Bug

## HTTP 协议 header 中 Content-Disposition 中文文件名乱码

**原因**

header 中只支持 ASCII，所以我们传输的文件名必须是 ASCII，当文件名为中文时，必须要将该中文转换成 ASCII。

**解决方法**

**方法一**

将中文文件名用 `ISO-8859-1` 进行重新编码。

```java
// 此时chrome解决了乱码，IE11没有
headers.add("Content-disposition","attachment;filename=" + new String("新的文本".getBytes("UTF-8"),"ISO-8859-1") + ".txt");
// 此时chrome和IE都解决了乱码
headers.add("Content-disposition","attachment;filename=" + new String("新的文本".getBytes("GBK"),"ISO-8859-1") + ".txt");
```

**方法二**

对中文文件名使用 URL 编码。

> **URL 编码（百分比编码）**
>
> URL 编码将字符转换为可通过因特网传输的格式。URL 只能使用 ASCII 字符集 通过因特网进行发送。由于 URL 通常包含 ASCII 集之外的字符，因此必须将 URL 转换为有效的 ASCII 格式。URL 编码使用后跟十六进制数字的 `%` 替代不安全的 ASCII 字符。URL 不能包含空格，通常使用加号 `+` 或 `%20` 替代空格。

```java
// 此时chrome和IE11都解决了乱码
headers.add("Content-disposition","attachment;filename=" + URLEncoder.encode("新的文本","UTF-8") + ".txt");
// 此时chrome和IE仍乱码
headers.add("Content-disposition","attachment;filename=" + URLEncoder.encode("新的文本","GBK") + ".txt");
```

**方法三**

使用 `filename*=charset'lang'value` ，其中 `charset` 给浏览器指明以什么编码方式来还原中文文件名，如 `filename*=UTF-8''value`，其中 `value` 为原始数据的 UTF-8 形式的 URL 编码。

```java
// 此时chrome和IE11都解决了乱码
headers.add("Content-Disposition","attachment;filename*=UTF-8''" + URLEncoder.encode("新的文本","UTF-8") + ".txt");
// 此时chrome和IE仍乱码
headers.add("Content-Disposition","attachment;filename*=GBK''" + URLEncoder.encode("新的文本","UTF-8") + ".txt");
// 此时chrome解决了乱码，IE11没有
headers.add("Content-disposition","attachment;filename*=GBK''" + URLEncoder.encode("新的文本","GBK") + ".txt");
```

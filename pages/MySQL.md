

```shell
# 连接MySQL
mysql -h {ip} -p {port} -u {username} -p {password}
# 查看MySQL的运行状态
> status
# 退出程序
> exit
```

# SQL

## 数据库操作

```sql
# 指定要使用的数据库
USE 数据库名
# 查看所有库
SHOW DATABASES [LIKE 'pattern']
# 查看当前使用的库
SELECT database()
```

### **创建库**

```sql
CREATE DATABASE [IF NOT EXISTS] 数据库名 数据库选项
```

* 数据库选项：

  * `CHARSET charset_name`：字符集

    查询 MySQL 支持的字符集种类：

    ```sql
    SHOW CHARACTER SET/CHARSET;
    ```

  * `COLLATE collation_name`：校验规则

    查询 MySQL 所支持的字符集的校验规则：

    ```sql
    SHOW COLLATION
    ```

> 字符集(*charset*)是用来定义 MySQL 存储字符串的方式。给定一系列字符并赋予对应的编码后，所有这些字符和编码对组成的集合就是字符集。例如，给定字符列表为{‘A’, ’B’}时，{‘A’=>0,‘B’=>1} 就是一个字符集。
>
> 校验规则(*collation*)定义了比较字符串的规则。确定比较规则后，才能在一个字符集上定义什么是等价的字符，以及字符之间的大小关系。
>
> 校验规则会影响到 `ORDER BY` 语句的顺序，会影响到 `WHERE` 条件中大于小于号筛选出来的结果，会影响 `DISTINCT`、`GROUP BY`、`HAVING` 语句的查询结果。另外，MySQL 建索引的时候，如果索引列是字符类型，也会影响索引创建，总之，凡是涉及到字符类型比较或排序的地方，都和校验规则有关。
>
> 校验规则命名惯例：以对应的字符集名称开头；以 `ci` (表示大小写不敏感)、`cs` (表示大小写敏感)或 `bin` (表示按编码值比较)结尾。例如：在校验规则 `utf8_general_ci` 下，字符 `a` 和 `A` 是等价的。
>
> 每种校验规则唯一对应一种字符集，但一个字符集可以对应多种校验规则。

### **修改库**

```sql
ALTER DATABASE 数据库名 数据库选项;
```

### **删除库**

```sql
DROP DATABASE [IF EXISTS] 数据库名;
```

## 表操作

```sql
# 查看所有表
SHOW TABLES [LIKE 'pattern'];
SHOW TABLES FROM 数据库名;
# 查看表结构
SHOW CREATE TABLE 表名;
DESC/DESCRIBE 表名;
EXPLAIN 表名;
SHOW COLUMNS FROM 表名 [LIKE 'pattern'];
SHOW TABLE STATUS [FROM 数据库名] [LIKE 'pattern'];
```

#### **创建表**

```sql
CREATE [TEMPORARY] TABLE [IF NOT EXISTS] [库名.]表名 (表结构定义)[表选项];
```

* `TEMPORARY`： 表示该表为临时表，只存在于当前会话。

* 表结构定义：由数个字段定义组成，每个字段定义由逗号隔开。

  字段定义：`字段名 数据类型 [NOT NULL | NULL] [DEFAULT default_value] [AUTO_INCREMENT] [UNIQUE [KEY] | [PRIMARY] KEY]`

* 表选项：

  * `CHARSET = charset_name`：字符集，如果表没有设定，则使用数据库字符集
  * `ENGINE = engine_name`：存储引擎，表在管理数据时采用的不同的数据结构，结构不同会导致处理方式、提供的特性操作等不同

#### **修改表**

修改表选项：

```sql
ALTER TABLE 表名 表选项;
```

对表进行重命名：

```sql
RENAME TABLE 原表名 TO 新表名;
# 复制表到另一个数据库中
RENAME TABLE 原表名 to 数据库名.新表名;
```

修改表的字段：

```sql
ALTER TABLE 表名 操作名;
```

操作名：

* `ADD [COLUMN] 字段定义 [AFTER 字段名/FIRST]`：增加字段
  * `AFTER 字段名`：增加的字段放在该字段后
  * `FIRST`：增加的字段放在首位
* `DROP [COLUMN] 字段名`：删除字段
* `MODIFY [COLUMN] 字段名 字段属性`：修改字段属性
* `CHANGE [COLUMN] 原字段名 新字段名 字段属性`：修改字段属性、重命名字段
* `ADD PRIMARY KEY (字段名)`：创建主键
* `ADD UNIQUE [索引名] (字段名)`：创建唯一索引
* `ADD INDEX [索引名] (字段名)`：创建普通索引
* `DROP PRIMARY KEY`：删除主键，删除主键前需先删除 `auto_increment` 属性
* `DROP INDEX`：删除索引

#### **删除表**

```sql
DROP TABLE [IF EXISTS] 表名;
```

#### **清空表数据**

```sql
TRUNCATE [TABLE] 表名;
```

#### **复制表**

```sql
# 复制表的结构
CREATE TABLE 表名 LIKE 被复制表名;
# 复制表结构和数据
CREATE TABLE 表名 [AS] SELECT * FROM 被复制表名;
```

### 数据操作

#### **增加(Create)**

```sql
INSERT [INTO]/REPLACE 表名 [(字段列表)] VALUES (值列表)[,(值列表),...];
```

如果要插入的值列表包含所有字段且顺序一致，则可以省略字段列表。可同时插入多条数据记录。

#### **删除(Delete)**

```sql
DELETE FROM 表名 [删除条件子句];
```

没有条件子句，则会删除所有数据。

#### **更新(Update)**

```sql
UPDATE 表名 SET 字段名 = 新值[,字段名 = 新值][更新条件];
```

#### **检索(Retrieve)**

```sql
SELECT 字段列表 FROM 表名 [其他子句];
```

### SELECT子句

```sql
SELECT [ALL|DISTINCT] select_expr FROM -> WHERE -> GROUP BY [聚集函数] ->
HAVING -> ORDER BY -> LIMIT
```

1. `ALL`，`DISTINCT` 选项

   `ALL`：全部记录（默认）

   `DISTINCT`：去除重复记录

2. `select_expr` 

可以用 * 表示所有字段。

```sql
# 查询所有数据
SELECT * FROM tb;
```

可以使用表达式（计算公式，函数调用）。

```sql
SELECT num+25,now() FROM tb;
```

可以使用 `AS` 关键字为每个列设置别名，也可省略 `AS` 。

```sql
SELECT num+25 AS add25 FROM tb;
```

3. `FROM` 子句

用于标识查询来源。

可以使用 `AS` 关键字为表设置别名。

```sql
SELECT * FROM tb1 AS t1, tb2 AS t2;
```

4. `WHERE` 子句

筛选从 `FROM` 获得的数据。

5. `GROUP BY` 子句，分组子句

```sql
GROUP BY 字段/别名 [排序方式]
```

* 排序方式
  * `ASC`：升序（默认）
  * `DESC`：降序

以下聚集函数需配合 `GROUP BY` 使用：

>  聚集函数：运行在行组上，计算和返回单个值的函数。

`count`：返回不同的非NULL值数目，`count(*)`、`count(字段)`

`sum`：求和

`max`：求最大值

`min`：求最小值

`avg`：求平均值

6. `HAVING` 子句，条件子句

与 `WHERE` 功能、用法相同，执行时机不同。

* `WHERE` 在开始时执行检测数据，对原数据进行过滤；`HAVING` 对筛选出的结果再次进行过滤。
* `WHERE` 字段必须是数据表存在的；`HAVING` 字段必须是查询出来的。
* `WHERE` 不可以使用字段的别名，`HAVING` 可以，因为执行 `WHERE` 代码时，可能尚未确定列值。
* `WHERE` 不可以使用聚集函数；一般需用聚集函数才会用 `HAVING`

7. `ORDER BY` 子句，排序子句

`ORDER BY` 子句取一个或多个列的名字，据此对输出进行排序。

```sql
ORDER BY 排序字段/别名 排序方式 [,排序字段/别名 排序方式]...
```

8. `LIMIT` 子句

检索查询返回的行的一部分。

```sql
LIMIT [起始位置,]结束位置;
LIMIT 结束位置 OFFSET 起始位置;
```

起始位置索引从 0 开始，可省略。

#### **EXISTS**

```sql
SELECT * FROM A WHERE EXISTS (SELECT 1 FROM B WHERE B.id = A.id);
```

**`EXISTS` 执行顺序：**

1、首先执行一次外部查询，并缓存结果集，如 SELECT * FROM A

2、遍历外部查询结果集的每一行记录 R ，代入子查询中作为条件进行查询，如 SELECT 1 FROM B WHERE B.id = A.id

3、如果子查询有返回结果，则 `EXISTS` 子句返回 `true`，这一行 R 可作为外部查询的结果行，否则不能作为结果

#### IN

`IN` 常用于 `WHERE` 表达式中，其作用是查询某个范围内的数据。

```sql
select * from where field in (value1,value2,value3,…) 
```

### UNION

`UNION` 操作符用于合并两个或多个 `SELECT` 语句的结果集。

注意，`UNION` 内部的每个 `SELECT` 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每个 `SELECT` 语句中的列的顺序必须相同。

```sql
 SELECT ... UNION [ALL|DISTINCT] SELECT ...
```

默认为 `DISTINCT`，`UNION` 操作符选取不同的值。如果允许重复的值，请使用 `ALL`。



### 其他

```sql
# 查看当前系统时间
SELECT now();
# 查看当前用户
SELECT user();
# 查看MySQL版本
SELECT version();
```

## 函数

### INSTR

`INSTR()` 函数获取子串第一次出现的索引，如果没有找到，则返回0（从1开始）。

```sql
INSTR(str,substr)
```

参数说明：

* `str` ：源字符串
* `substr` ：要搜索的子串

例：

```sql
SELECT INSTR('apple','a')
```

返回的查询结果是1（`a` 出现在字符串 `apple` 中的第1个索引）。

### IF

```sql
SELECT IF(score >= 60,'及格'，'不及格')
```

## 流程控制

### CASE

```sql
# 类似 Java 中的 switch 语句
CASE 要判断的字段或表达式
WHEN 常量1 THEN 要显示的值1或语句1
WHEN 常量2 THEN 要显示的值2或语句2
...
ELSE 要显示的值n或语句n
END
# 类似 Java 中的多重 if 语句
CASE 
WHEN 常量1 THEN 要显示的值1或语句1
WHEN 常量2 THEN 要显示的值2或语句2
...
ELSE 要显示的值n或语句n
END
```

案例1：查询员工的工资，要求部门号为1的员工显示原始工资，部门号为2的员工显示原始工资的1.2倍，部门号为3的员工显示原始工资的1.5倍。

```sql
SELECT
	salary,
	department,
CASE
	department 
    WHEN 1 THEN salary * 1 
    WHEN 2 THEN salary * 1.2 
    WHEN 3 THEN salary * 1.5 ELSE salary 
END AS current_salary
FROM employee
```

案例2：查询员工的工资情况，如果工资>=10000，显示A级别；如果10000>工资>=5000，显示B级别；如果工资<5000，显示C级别。

```sql
SELECT salary,
CASE
WHEN salary >= 10000 THEN 'A'
WHEN salary >= 5000 THEN 'B'
ELSE 'C'
END AS level
FROM employee
```

# 事务

## **事务的四大特性**

**原子性(*Atomicity*)** 事务是数据库的逻辑工作单位，原子性是指事务包含的所有操作要么全部成功，要么全部失败。

**一致性(*Consistency*)** 一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。一致性与原子性是密切相关的。

以转账举例：假设用户A和用户B两者的钱加起来一共是100，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来都应该还是100，这就是事务的一致性。

**隔离性(*Isolation*)** 一个事务的执行不能被其他事务干扰。

比如多个用户对同一张表进行操作时，数据库为每一个用户开启一个事务，不能被其他事务干扰，多个并发事务之间是相互隔离的。

**持久性(*Durability*)** 一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。

## 并发事务带来的问题

### **脏读(Dirty Read)**

<img src="D:\File\Document\编程\img\脏读.jpg" style="zoom: 80%;" />

1、在事务A执行过程中，事务A对数据资源进行了修改，事务B读取了事务A修改后的数据。

2、由于某些原因，事务A并没有完成提交，发生了回滚操作，则事务B读取的数据就是脏数据。

这种读取到另一个事务未提交的数据的现象就是脏读。

### 不可重复读(Nonrepeatable Read)

<img src="D:\File\Document\编程\img\不可重复读.jpg" style="zoom:80%;" />

事务B读取了两次数据资源，在这两次读取的过程中事务A修改了数据，导致事务B在这两次读取出来的数据不一致。

这种在同一个事务中，前后两次读取的数据不一致的现象就是不可重复读。

### 幻读(Phantom Read)

<img src="D:\File\Document\编程\img\幻读.jpg" style="zoom:80%;" />

事务B前后两次读取同一个范围的数据，在事务B两次读取的过程中事务A新增了数据，导致事务B后一次读取到前一次查询没有看到的行。

幻读和不可重复读有些类似，但是幻读强调的是集合的增减，而不是单条数据的更新。

### 第一类更新丢失

<img src="D:\File\Document\编程\img\第一类更新丢失.jpg" style="zoom:80%;" />

事务A和事务B都对数据进行更新，但是事务A由于某种原因事务回滚了，把已经提交的事务B的更新数据给覆盖了。这种现象就是第一类更新丢失。

### 第二类更新丢失

<img src="D:\File\Document\编程\img\第二类更新丢失.jpg" style="zoom:80%;" />

与第一类更新丢失有点类似，也是两个事务同时对数据进行更新，但是事务A的更新把已提交的事务B的更新数据给覆盖了。这种现象就是第二类更新丢失。

## 事务隔离级别

为了解决以上的问题，主流的关系型数据库都会提供四种事务的隔离级别。**事务隔离级别从低到高分别是：读未提交、读已提交、可重复读、串行化。**事务隔离级别等级越高，越能保证数据的一致性和完整性，但是执行效率也越低。所以在设置数据库的事务隔离级别时需要做一下权衡。**MySQL默认的隔离级别是可重复读。**

### **读未提交**

读未提交(*Read Uncommitted*)，是最低的隔离级别，所有的事务都可以看到其他未提交的事务的执行结果。只能防止第一类更新丢失，不能解决脏读，可重复读，幻读，所以很少应用于实际项目。

### **读已提交**

读已提交(*Read Committed*)， 在该隔离级别下，一个事务的更新操作结果只有在**该事务提交之后，另一个事务才可能读取到同一笔数据更新后的结果**。可以防止脏读和第一类更新丢失，但是不能解决可重复读和幻读的问题。

### **可重复读**

可重复读(*Repeatable Read*)，在该隔离级别下，一个事务多次读同一个数据，在这个事务还没结束时，其他事务不能访问该数据（包括读写），这样就可以在同一个事务内两次读到的数据是一样的。可以防止脏读、不可重复读、第一类更新丢失、第二类更新丢失的问题，不过还是会出现幻读。

### **串行化**

串行化(*Serializable*)，这是最高的隔离级别。它要求事务序列化执行，事务只能一个接着一个地执行，不能并发执行。在这个级别，可以解决上面提到的所有并发问题，但可能导致大量的超时现象和锁竞争，通常不会用这个隔离级别。

| 隔离级别 | 脏读 | 不可重复读 | 幻读 | 第一类更新丢失 | 第二类更新丢失 |
| :------: | :--: | :--------: | :--: | :------------: | :------------: |
| 读未提交 |  ✓   |     ✓      |  ✓   |       ×        |       ✓        |
| 读已提交 |  ×   |     ✓      |  ✓   |       ×        |       ✓        |
| 可重复读 |  ×   |     ×      |  ✓   |       ×        |       ×        |
|  串行化  |  ×   |     ×      |  ×   |       ×        |       ×        |

## MySQL中的事务

```sql
# 开启一个事务,所有被执行的SQL语句均被认作当前事务内的SQL语句
BEGIN/START TRANSACTION;
# 提交事务
COMMIT;
# 事务回滚
ROLLBACK;
# 允许在事务中创建一个保存点，一个事务中可以有多个保存点
SAVEPOINT identifier;
# 把事务回滚到标记点
ROLLBACK TO identifier; 
# 删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常
RELEASE SAVEPOINT identifier;
```

> 注意：在 MySQL 中只有使用了 InnoDB 数据库引擎的数据库或表才支持事务；事务不能被嵌套。

# 索引

> 索引是一种用于快速查询和检索数据的数据结构。索引的作用就相当于目录的作用。打个比方，我们在查字典的时候，如果没有目录，那我们就只能一页一页的去找我们需要查的那个字，速度很慢。如果有目录了，我们只需要先去目录里查找字的位置，然后直接翻到那一页就行了。

## 索引类型

### 主键索引(Primary Key)

数据表的主键列使用的就是主键索引。

**一张数据表有只能有一个主键，并且主键不能为 NULL，不能重复。**

> 在 MySQL 的 InnoDB 的表中，当没有显示的指定表的主键时，InnoDB 会自动先检查表中是否有唯一索引的字段，如果有，则选择该字段为默认的主键，否则 InnoDB 将会自动创建一个 6 Byte 的自增主键。

### **唯一索引(Unique Key)**

**唯一索引的属性列不能出现重复的数据，但是允许数据为 NULL，一张表允许创建多个唯一索引。** 建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。

### **普通索引(Index)**

普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 NULL。

### **全文索引(Full Text)**

全文索引，通过建立倒排索引，可以极大的提升检索效率，解决"是否包含字段"的问题。

> MySQL 5.6 之前只有 MyISAM 引擎支持全文索引，5.6 之后 InnoDB 也支持了全文索引，但是不支持中文全文索引。在 5.7.6 版本，MySQL内置了 ngram 全文解析器，用来支持亚洲语种的分词。

> 倒排索引(*Inverted Index*)，也常被称为反向索引、置入档案或反向档案，是一种索引方法，被用来存储在全文搜索下某个单词在一个文档或者一组文档中的存储位置的映射。它是文档检索系统中最常用的数据结构。

### 联合索引

 两个或更多个列上的索引被称作联合索引，对于联合索引，MySQL 从左到右的使用索引中的字段，一个查询可以只使用索引中的一部分，但只能是最左侧部分。例如索引是 `a,b,c`，可以支持 `a`、`a,b`、`a,b,c` 3 种组合进行查找，但不支持 `b,c` 进行查找 。当最左侧字段是常量引用时，索引就十分有效。

### 聚集索引与非聚集索引

#### 聚集索引

聚集索引即索引结构和数据一起存放的索引，主键索引属于聚集索引。

> 在 MySQL 中，InnoDB 引擎的表的 .ibd 文件就包含了该表的索引和数据，对于 InnoDB 引擎表来说，该表的索引(B+树)的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。

**聚集索引的优点**

聚集索引的查询速度非常的快，因为整个 B+ 树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。

**聚集索引的缺点**

1. **依赖于有序的数据** ：因为 B+ 树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或 UUID 这种又长又难比较的数据，插入或查找的速度肯定比较慢。
2. **更新代价大** ： 如果对索引列的数据被修改时，那么对应的索引也将会被修改， 而且况聚集索引的叶子节点还存放着数据，修改代价肯定是较大的， 所以对于主键索引来说，主键一般都是不可被修改的。

#### 非聚集索引

非聚集索引即索引结构和数据分开存放的索引，二级索引属于非聚集索引。

> MyISAM 引擎的表的 .MYI 文件包含了表的索引， 该表的索引(B+树)的每个非叶子节点存储索引， 叶子节点存储索引和索引对应数据的指针，指向 .MYD 文件的数据。

非聚集索引的叶子节点并不一定存放数据的指针， 因为二级索引的叶子节点就存放的是主键，根据主键再回表查数据。

**非聚集索引的优点**

更新代价比聚集索引要小。非聚集索引的更新代价就没有聚集索引那么大了，非聚集索引的叶子节点是不存放数据的。

**非聚集索引的缺点**

1. 跟聚集索引一样，非聚集索引也依赖于有序的数据。
2. 可能会二次查询(回表) ：这应该是非聚集索引最大的缺点了。当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。

### 覆盖索引

如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为覆盖索引。我们知道在 InnoDB 存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要回表，也就是要通过主键再查找一次，这样就会比较慢。覆盖索引就是把要查询出的列和索引是对应的，不做回表操作。

**覆盖索引即需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了， 而无需回表查询。**

> 如主键索引，如果一条 SQL 需要查询主键，那么正好根据主键索引就可以查到主键。
>
> 再如普通索引，如果一条 SQL 需要查询 name，name 字段正好有索引， 那么直接根据这个索引就可以查到数据，也无需回表。

## 创建索引的注意事项

**1.选择合适的字段创建索引**

- **不为 NULL 的字段** ：索引字段的数据应该尽量不为 NULL，因为对于数据为 NULL 的字段，数据库较难优化。如果字段频繁被查询，但又避免不了为 NULL，建议使用 0，1，true，false 这样语义较为清晰的短值或短字符作为替代。
- **被频繁查询的字段** ：我们创建索引的字段应该是查询操作非常频繁的字段。
- **被作为条件查询的字段** ：被作为 WHERE 条件查询的字段，应该被考虑建立索引。
- **频繁需要排序的字段** ：索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。
- **被经常频繁用于连接的字段** ：经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率。

**2.被频繁更新的字段应该慎重建立索引**

虽然索引能带来查询上的效率，但是维护索引的成本也是不小的。 如果一个字段不被经常查询，反而被经常修改，那么就更不应该在这种字段上建立索引了。

**3.尽可能的考虑建立联合索引而不是单列索引**

因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗 B+树。如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引时，耗费的时间也是较多的。如果是联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升。

**4.注意避免冗余索引**

冗余索引指的是索引的功能相同，能够命中索引(a, b)就肯定能命中索引(a) ，那么索引(a)就是冗余索引。能够命中前者的查询肯定是能够命中后者的。在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。

## 使用索引的一些建议

- 对于中到大型表索引都是非常有效的，但是特大型表的话维护开销会很大，不适合建索引
- 避免 WHERE 子句中对字段施加函数，这会造成无法命中索引。
- 在使用 InnoDB 时使用与业务无关的自增主键作为主键，即使用逻辑主键，而不要使用业务主键。
- 删除长期未使用的索引，不用的索引的存在会造成不必要的性能损耗 MySQL 5.7 可以通过查询 sys 库的 schema_unused_indexes 视图来查询哪些索引从未被使用。
- 在使用 LIMIT OFFSET 查询缓慢时，可以借助索引来提高性能。

## MySQL为表字段添加索引

```sql
# 添加 PRIMARY KEY（主键索引）
ALTER TABLE `table_name` ADD PRIMARY KEY ( `column` )
# 添加 UNIQUE（唯一索引）
ALTER TABLE `table_name` ADD UNIQUE ( `column` )
# 添加 INDEX（普通索引）
ALTER TABLE `table_name` ADD INDEX index_name ( `column` )
# 添加 FULLTEXT（全文索引）
ALTER TABLE `table_name` ADD FULLTEXT ( `column`)
# 添加多列索引
ALTER TABLE `table_name` ADD INDEX index_name ( `column1`, `column2`, `column3` )
```

# MySQL优化

## 数据库命令规范

- 所有数据库对象名称必须使用小写字母并用下划线分割
- 所有数据库对象名称禁止使用 MySQL 保留关键字（如果表名中包含关键字查询时，需要将其用单引号括起来）
- 数据库对象的命名要能做到见名识意，并且最后不要超过 32 个字符
- 临时库表必须以 `tmp` 为前缀并以日期为后缀，备份表必须以 `bak` 为前缀并以日期 (时间戳) 为后缀
- 所有存储相同数据的列名和列类型必须一致（一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低）

## 数据库基本设计规范

### 1、所有表必须使用 InnoDB 存储引擎

没有特殊要求（即 InnoDB 无法满足的功能如：列存储，存储空间数据等）的情况下，所有表必须使用 InnoDB 存储引擎（MySQL 5.5 之前默认使用 MyISAM，5.6 以后默认的为 InnoDB）。

Innodb 支持事务，支持行级锁，更好的恢复性，高并发下性能更好。

### 2、数据库和表的字符集统一使用 UTF-8

兼容性更好，统一字符集可以避免由于字符集转换产生的乱码，不同的字符集进行比较前需要进行转换会造成索引失效，如果数据库中有存储 emoji 表情的需要，字符集需要采用 `utf8mb4` 字符集。

### 3、所有表和字段都需要添加注释

使用 `comment` 从句添加表和列的备注，从一开始就进行数据字典的维护。

### 4. 尽量控制单表数据量的大小,建议控制在 500 万以内

500 万并不是 MySQL 数据库的限制，过大会造成修改表结构，备份，恢复都会有很大的问题。

可以用历史数据归档（应用于日志数据），分库分表（应用于业务数据）等手段来控制数据量大小。

### 5、谨慎使用 MySQL 分区表

分区表在物理上表现为多个文件，在逻辑上表现为一个表。

谨慎选择分区键，跨分区查询效率可能更低。

建议采用物理分表的方式管理大数据。

### 6、尽量做到冷热数据分离，减小表的宽度

> MySQL 限制每个表最多存储 4096 列，并且每一行数据的大小不能超过 65535 字节。

减少磁盘 IO，保证热数据的内存缓存命中率（表越宽，把表装载进内存缓冲池时所占用的内存也就越大，也会消耗更多的 IO）。

更有效的利用缓存，避免读入无用的冷数据。

经常一起使用的列放到一个表中（避免更多的关联操作）。

### 7、禁止在表中建立预留字段

预留字段的命名很难做到见名识义。

预留字段无法确认存储的数据类型，所以无法选择合适的类型。

对预留字段类型的修改，会对表进行锁定。

### 8、禁止在数据库中存储图片，文件等大的二进制数据

通常文件很大，会短时间内造成数据量快速增长，数据库进行数据库读取时，通常会进行大量的随机 IO 操作，文件很大时，IO 操作很耗时。

通常存储于文件服务器，数据库只存储文件地址信息。

### 9、 禁止在线上做数据库压力测试

### 10、禁止从开发环境,测试环境直接连接生产环境数据库

## 索引优化

### 索引设计规范

#### 1、限制每张表上的索引数量，建议单张表索引不超过 5 个

索引并不是越多越好！索引可以提高效率同样可以降低效率。

索引可以增加查询效率，但同样也会降低插入和更新的效率，甚至有些情况下会降低查询效率。

因为 MySQL 优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，就会增加 MySQL 优化器生成执行计划的时间，同样会降低查询性能。

#### 2、禁止给表中的每一列都建立单独的索引

5.6 版本之前，一个 SQL 只能使用到一个表中的一个索引，5.6 以后，虽然有了合并索引的优化方式，但是还是远远没有使用一个联合索引的查询方式好。

#### 3、每个 InnoDB 表必须有个主键

InnoDB 是一种索引组织表：数据的存储的逻辑顺序和索引的顺序是相同的。每个表都可以有多个索引，但是表的存储顺序只能有一种。

InnoDB 是按照主键索引的顺序来组织表的。

- 不要使用更新频繁的列作为主键，不适用多列主键（相当于联合索引）
- 不要使用 `UUID`，`MD5`，`HASH`，字符串列作为主键（无法保证数据的顺序增长）
- 主键建议使用自增 ID 值

#### 4、避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）

- 重复索引示例：primary key(id)、index(id)、unique index(id)
- 冗余索引示例：index(a,b,c)、index(a,b)、index(a)

#### 5、 对于频繁的查询优先考虑使用覆盖索引

> 覆盖索引：就是包含了所有查询字段(`WHERE`,`SELECT`,`ORDER BY`,`GROUP BY` 包含的字段)的索引

**覆盖索引的好处：**

- **避免 InnoDB 表进行索引的二次查询:** InnoDB 是以聚集索引的顺序来存储的，对于 InnoDB 来说，二级索引在叶子节点中所保存的是行的主键信息，如果是用二级索引查询数据的话，在查找到相应的键值后，还要通过主键进行二次查询才能获取我们真实所需要的数据。而在覆盖索引中，二级索引的键值中可以获取所有的数据，避免了对主键的二次查询 ，减少了 IO 操作，提升了查询效率。
- **可以把随机 IO 变成顺序 IO 加快查询效率:** 由于覆盖索引是按键值的顺序存储的，对于 IO 密集型的范围查找来说，对比随机从磁盘读取每一行的数据 IO 要少的多，因此利用覆盖索引在访问时也可以把磁盘的随机读取的 IO 转变成索引查找的顺序 IO。

#### **6、尽量避免使用外键约束**

- 不建议使用外键约束（*Foreign Key*），但一定要在表与表之间的关联键上建立索引
- 外键可用于保证数据的参照完整性，但建议在业务端实现
- 外键会影响父表和子表的写操作从而降低性能

### 常见索引列建议

- 出现在 `SELECT`、`UPDATE`、`DELETE` 语句的 `WHERE` 从句中的列
- 包含在 `ORDER BY`、`GROUP BY`、`DISTINCT` 中的字段
- 并不要将符合 1 和 2 中的字段的列都建立一个索引， 通常将 1、2 中的字段建立联合索引效果更好
- 多表 `JOIN` 的关联列

### 如何选择索引列的顺序

建立索引的目的是：希望通过索引进行数据查找，减少随机 IO，增加查询性能 ，索引能过滤出越少的数据，则从磁盘中读入的数据也就越少。

- 区分度最高的放在联合索引的最左侧（区分度 = 列中不同值的数量/列的总行数）
- 尽量把字段长度小的列放在联合索引的最左侧（因为字段长度越小，一页能存储的数据量越大，IO 性能也就越好）
- 使用最频繁的列放到联合索引的左侧（这样可以比较少的建立一些索引）

### 常见索引失效原因

<img src="D:\File\Document\编程\img\索引失效常见原因.jpg" style="zoom: 50%;" />

## EXPLAIN输出列

<img src="D:\File\Document\编程\img\执行计划显示列.jpg" style="zoom:50%;" />

|     列名      |                             说明                             |
| :-----------: | :----------------------------------------------------------: |
|      id       | 执行编号，标识 `SELECT` 所属的行。如果在语句中没子查询或关联查询，只有唯一的 `SELECT`，每行都将显示 1。否则，内层的 `SELECT` 语句一般会顺序编号，对应于其在原始语句中的位置。 |
|  select_type  | 显示本行是简单或复杂 `SELECT`。如果查询有任何复杂的子查询，则最外层标记为 `PRIMARY`。 |
|     table     |                        访问引用哪个表                        |
|     type      | 数据访问/读取操作类型(`ALL`、`index`、`range`、`ref`、`eq_ref`、`const/system`、`NULL`)。 |
| possible_keys |             显示哪一些索引可能有利于高效的查找。             |
|      key      |           显示 MySQL 决定采用哪个索引来优化查询。            |
|    key_len    |              显示 MySQL 在索引里使用的字节数。               |
|      ref      | 显示了之前的表在 `key` 列记录的索引中查找值所用的列或常量。  |
|     rows      | 为了找到所需的行而需要读取的行数，估算值，不精确。通过把所有`rows` 列值相乘，可粗略估算整个查询会检查的行数。 |
|     Extra     |                           额外信息                           |

### id

`id` 是用来顺序标识整个查询中 `SELECT` 语句的，在嵌套查询中 `id` 越大的语句越先执行。如果这一行用来说明的是其他行的联合结果，该值可能为 `NULL`。

### select_type

表示查询的类型。

|        类型        |                             说明                             |
| :----------------: | :----------------------------------------------------------: |
|       simple       |             简单子查询，不包含子查询和 `UNION`。             |
|      primary       |    包含子查询或者`UNION`，最外层的部分标记为 `primary`。     |
|      subquery      | 一般子查询中的子查询被标记为 `subquery`，也就是位于 `SELECT` 列表中的查询。 |
|      derived       | 派生表，该临时表是从子查询派生出来的，位于 `FROM` 中的子查询。 |
|       union        | 位于 `UNION` 中第二个及其以后的子查询被标记为 `union`，第一个就被标记为 `primary` 如果是 `UNION` 位于 `FROM` 中则标记为 `derived`。 |
|    union result    | 用来从匿名临时表里检索结果的 `SELECT` 被标记为 `union result`。 |
|  dependent union   | 顾名思义，首先需要满足 `UNION` 的条件，及 `UNION` 中第二个以及后面的 `SELECT` 语句，同时该语句依赖外部的查询。 |
|      subquery      |                子查询中第一个 `SELECT` 语句。                |
| dependent subquery |           和 `DEPENDENT UNION` 相对 `UNION` 一样。           |

### table

对应行正在访问哪一个表，表名或者别名

- 关联优化器会为查询选择关联顺序，左侧深度优先
- 当 `FROM` 中有子查询的时候，表名是 `derivedN` 的形式，`N` 指向子查询，也就是 `EXPLAIN` 结果中的下一列
- 当有 `union result` 的时候，表名是 `union1,2 ...` 的形式，`1,2 ...`表示参与 `UNION` 的 `query id`

注意：MySQL 对待这些临时表和普通表一样，但是这些表是没有任何索引。

### type

`type` 显示的是访问类型，是较为重要的一个指标，结果值从好到坏依次是：
 `system` > `const` > `eq_ref` > `ref` > `fulltext` > `ref_or_null` > `index_merge` > `unique_subquery` > `index_subquery` > `range` > `index` > `ALL` ，一般来说，得保证查询至少达到 `range` 级别，最好能达到 `ref`。

| 类型   | 说明                                                         |
| ------ | ------------------------------------------------------------ |
| All    | 最坏的情况，全表扫描。                                       |
| index  | 和全表扫描一样。只是扫描表的时候按照索引次序进行而不是行。主要优点就是避免了排序，但是开销仍然非常大。如在 `Extra` 列看到 `Using index`，说明正在使用覆盖索引，只扫描索引的数据，它比按索引次序全表扫描的开销要小很多。 |
| range  | 范围扫描，一个有限制的索引扫描。`key` 列显示使用了哪个索引。当使用 `=`、`<>`、`>`、`>=`、`<`、`<=`、`IS NULL`、`<=>`、`BETWEEN` 或者 `IN` 操作符，用常量比较关键字列时，可以使用 `range`。 |
| ref    | 一种索引访问，它返回所有匹配某个单个值的行。此类索引访问只有当使用非唯一性索引或唯一性索引非唯一性前缀时才会发生。这个类型跟 `eq_ref` 不同的是，它用在关联操作只使用了索引的最左前缀，或者索引不是 `UNIQUE` 和 `PRIMARY KEY`。`ref` 可以用于使用 `=` 或 `<=>` 操作符的带索引的列。 |
| eq_ref | 最多只返回一条符合条件的记录，使用唯一性索引或主键查找时会发生 （高效）。 |
| const  | 当确定最多只会有一行匹配的时候，MySQL 优化器会在查询前读取它而且只读取一次，因此非常快。当主键放入 `WHERE` 子句时，MySQL 把这个查询转为一个常量（高效）。 |
| system | 这是 `const` 连接类型的一种特例，表仅有一行满足条件。        |
| Null   | 意味说 MySQL 能在优化阶段分解查询语句，在执行阶段甚至用不到访问表或索引（高效）。 |

### possible_keys

显示查询使用了哪些索引，表示该索引可以进行高效地查找，但是列出来的索引对于后续优化过程可能是没有用的。

### key

`key` 列显示 MySQL 实际决定使用的索引。如果没有选择索引，键是 `NULL`。要想强制MySQL 使用或忽视 `possible_keys` 列中的索引，在查询中使用 `FORCE INDEX`、`USE INDEX` 或者 `IGNORE INDEX`。

### key_len

`key_len` 列显示 MySQL 决定使用的索引长度。如果索引是 `NULL`，则长度为 `NULL`。在不损失精确性的情况下，长度越短越好 。

### ref

`ref` 列显示使用哪个列或常数与 `key` 一起从表中选择行。

### rows

`rows` 列显示 MySQL 认为它执行查询时必须检查的行数（注意这是一个预估值）。

### Extra

`Extra` 是 `EXPLAIN` 输出中另外一个很重要的列，该列显示 `MySQL` 在查询过程中的一些详细信息，MySQL 查询优化器执行查询的过程中对查询计划的重要补充信息。

| 类型                         | 说明                                                         |
| ---------------------------- | ------------------------------------------------------------ |
| Using filesort               | MySQL 有两种方式可以生成有序的结果，通过排序操作或者使用索引，当 `Extra` 中出现了 `Using filesort` 说明 MySQL 使用了后者，但注意虽然叫 `filesort` 但并不是说明就是用了文件来进行排序，只要可能排序都是在内存里完成的。大部分情况下利用索引排序更快，所以一般这时也要考虑优化查询了。使用文件完成排序操作，这是可能是 `ORDER BY`，`GROUP BY`语句的结果，这可能是一个CPU密集型的过程，可以通过选择合适的索引来改进性能，用索引来为查询结果排序。 |
| Using temporary              | 用临时表保存中间结果，常用于 `GROUP BY` 和 `ORDER BY` 操作中，一般看到它说明查询需要优化了，就算避免不了临时表的使用也要尽量避免硬盘临时表的使用。 |
| Not exists                   | MySQL 优化了 `LEFT JOIN`，一旦它找到了匹配 `LEFT JOIN` 标准的行，就不再搜索了。 |
| Using index                  | 说明查询是覆盖了索引的，不需要读取数据文件，从索引树（索引文件）中即可获得信息。如果同时出现 `Using where`，表明索引被用来执行索引键值的查找，没有 `Using where`，表明索引用来读取数据而非执行查找动作。这是 MySQL 服务层完成的，但无需再回表查询记录。 |
| Using index condition        | 这是 MySQL 5.6 出来的新特性，叫做“索引条件推送”。简单说一点就是 MySQL 原来在索引上是不能执行如 `LIKE` 这样的操作的，但是现在可以了，这样减少了不必要的 IO 操作，但是只能用在二级索引上。 |
| Using where                  | 使用了 `WHERE` 从句来限制哪些行将与下一张表匹配或者是返回给用户。注意：`Extra` 列出现 `Using where` 表示 MySQL 服务器将存储引擎返回服务层以后再应用 `WHERE` 条件过滤。 |
| Using join buffer            | 使用了连接缓存：`Block Nested Loop`，连接算法是块嵌套循环连接；`Batched Key Access`，连接算法是批量索引连接。 |
| impossible where             | `WHERE` 子句的值总是 `false`，不能用来获取任何元组。         |
| select tables optimized away | 在没有 `GROUP BY` 子句的情况下，基于索引优化 `MIN/MAX` 操作，或者对于 MyISAM 存储引擎优化 `COUNT(*)` 操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化。 |
| distinct                     | 优化 `DISTINCT` 操作，在找到第一匹配的元组后即停止找同样值的动作。 |

## SELECT语句执行顺序

```sql
FROM <表名> 
ON <筛选条件> 
JOIN<join, left join, right join...> <表> 
WHERE <where条件>
GROUP BY <分组条件> <聚合函数> 
HAVING <分组筛选> 
SELECT <返回数据列表>
DISTINCT 
ORDER BY <排序条件>
LIMIT <行数限制>
```

## SQL优化策略

对于 MySQL 层优化一般遵从五个原则：

1. 减少数据访问： 设置合理的字段类型，启用压缩，通过索引访问等减少磁盘 IO
2. 返回更少的数据： 只返回需要的字段和数据分页处理 减少磁盘 IO 及网络 IO
3. 减少交互次数： 批量 DML 操作，函数存储等减少数据连接次数
4. 减少服务器 CPU 开销： 尽量减少数据库排序操作以及全表查询，减少 CPU 内存占用
5. 利用更多资源： 使用表分区，可以增加并行操作，更大限度利用 CPU 资源

总结到 SQL 优化中为:

- 最大化利用索引
- 尽可能避免全表扫描
- 减少无效数据的查询

### 一、避免出现 like '%x'

尽量避免在字段开头模糊查询，会导致数据库引擎放弃索引进行全表扫描。

```sql
SELECT * FROM t WHERE username LIKE '%x%'
```

优化方式：尽量在字段后面使用模糊查询。

```sql
SELECT * FROM t WHERE username LIKE 'x%'
```

如果需求是要在字段前使用模糊查询：

- 使用 MySQL 内置函数 `INSTR(str,substr)` 来匹配
- 使用 `FullText` 全文索引，用 `match against` 检索
- 数据量较大的情况，建议引用 `ElasticSearch`、`solr`，亿级数据量检索速度秒级
- 当表数据量较少（几千条），直接使用 `LIKE '%xx%'`。

### **二、 避免出现 SELECT \***

首先，`SELECT *` 操作在任何类型数据库中都不是一个好的 SQL 编写习惯。

使用 `SELECT *` 取出全部列，会让优化器无法完成索引覆盖扫描这类优化，会影响优化器对执行计划的选择，也会增加网络带宽消耗，更会带来额外的 IO，内存和 CPU 消耗。

建议提出业务实际需要的列数，将指定列名以取代 `SELECT *`。

### 三、用 UNION ALL 代替 UNION

使用 `UNION` 关键字后，可以获取排重后的数据，而如果使用 `UNION ALL` 关键字，可以获取所有数据，包含重复的数据。排重的过程需要遍历、排序和比较，它更耗时，更消耗 CPU 资源。除非是有些特殊的场景，比如 `UNION ALL` 之后，结果集中出现了重复数据，而业务场景中是不允许产生重复数据的，这时可以使用 `UNION`。

### 四、批量操作

批量操作减少了请求数据库的次数，提升了查询效率。

但需要注意的是，不建议一次批量操作太多的数据，如果数据太多数据库响应也会很慢。批量操作需要把握一个度，建议每批数据尽量控制在 500 以内。如果数据多于 500，则分多批次处理。

### 五、 LIMIT

* 在需要查询部分数据时，使用 `LIMIT` 减少查询数据的数量提高查询效率。

* 在删除或者修改数据时，为了防止误操作，导致删除或修改了不相干的数据，可以在 SQL 语句最后加上 `LIMIT`。

* 在一次查询中查询的数据量过大，如果不做任何限制，很容易造成接口超时，可以使用 `LIMIT` 限制查询的数据量。

### 六、分页

有时候，列表页在查询数据时，为了避免一次性返回过多的数据影响接口性能，一般会对查询接口做分页处理。

在 MySQL 中分页一般用的 `LIMIT` 关键字：

```sql
select id,name,age 
from user limit 10,20;
```

如果表中数据量少，用 `LIMIT` 关键字做分页，没啥问题。但如果表中数据量很多，用它就会出现性能问题。

比如现在分页参数变成了：

```sql
select id,name,age 
from user limit 1000000,20;
```

MySQL 会查到 1000020 条数据，然后丢弃前面的 1000000 条，只查后面的 20 条数据，这样非常浪费资源。

优化 SQL：

```sql
select id,name,age 
from user where id > 1000000 limit 20;
```

先找到上次分页最大的 id，然后利用 id 上的索引查询。不过该方案，要求 id 是连续的，并且有序的。

使用 `BETWEEN` ：

```sql
select id,name,age 
from user where id between 1000000 and 1000020;
```

需要注意的是 `BETWEEN` 要在唯一索引上分页，不然会出现每页大小不一致的问题。

### 七、用连接查询代替子查询

MySQL 执行子查询时，需要创建临时表，查询完毕后，需要再删除这些临时表，有一些额外的性能消耗。

### 八、JOIN 的表不宜过多

如果 `JOIN`太多，MySQL 在选择索引的时候会非常复杂，很容易选错索引。

### 九、分组

有很多业务场景需要使用 `GROUP BY`关键字，它主要的功能是去重和分组。通 `HAVING` 一起配合使用，表示分组后再根据一定的条件过滤数据。

```sql
select user_id,user_name from order
group by user_id
having user_id <= 200;
```

这种写法性能不好，它先把所有的订单根据用户 id 分组之后，再去过滤用户 id 大于等于 200 的用户。

分组是一个相对耗时的操作，可以先缩小数据的范围之后，再分组：

```sql
select user_id,user_name from order
where user_id <= 200
group by user_id
```

使用 `WHERE` 条件在分组前，就把多余的数据过滤掉了，这样分组时效率就会更高一些。

> 这种思路不仅限于优化分组。在做一些耗时的操作之前，应尽可能缩小数据范围，以提升效率。

# Trips

## 判断奇数的方法

* `mod(x,2) = 1`，如果余数是 1 就是奇数。
* `power(-1,x) = -1`，如果结果是 -1 就是奇数。
* `x % 2 = 1`，如果余数是 1 就是奇数。
* x & 1 = 1，如果是 1 就是奇数。

## 查看表中某个字段的所有重复数据

```sql
SELECT * 
FROM TableA
WHERE b IN ( SELECT b FROM TableA GROUP BY b HAVING COUNT ( b ) > 1 )
```

## 重置自动递增值为初始值

```sql
alter table table_name auto_increment=1
```

# Q&A

## DML & DDL

DML 是数据库操作语言(*Data Manipulation Language*)的缩写，是指对数据库中表记录的操作，主要包括表记录的插入(insert)、更新(update)、删除(delete)和查询(select)，是开发人员日常使用最频繁的操作。

DDL (*Data Definition Language*)是数据定义语言的缩写，简单来说，就是对数据库内部的对象进行创建、删除、修改的操作语言。它和 DML 语言的最大区别是 DML 只是对表内部数据的操作，而不涉及到表的定义、结构的修改，更不会涉及到其他对象。DDL 语句更多的被数据库管理员所使用，一般的开发人员很少使用。

## MyISAM & InnoDB

|              |     MyISAM     |           InnoDB           |
| :----------: | :------------: | :------------------------: |
|   索引类型   |   非聚簇索引   |          聚簇索引          |
|   支持事务   |       否       |             是             |
|   支持表锁   |       是       |             是             |
|   支持行锁   |       否       |             是             |
|   支持外键   |       否       |             是             |
| 支持全文索引 |       是       |             是             |
| 适合操作类型 | 大量SELECT语句 | 大量INSERT、UPDATE、DELETE |

MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是，两者的实现方式不太一样。

MyISAM 引擎中，B+Tree 叶节点的 data 域存放的是数据记录的地址。在索引检索的时候，首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“非聚集索引”。

InnoDB 引擎中，其数据文件本身就是索引文件。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。这个索引的 key 是数据表的主键，因此 InnoDB 表数据文件本身就是主索引。这被称为“聚簇索引（或聚集索引）”，而其余的索引都作为辅助索引，辅助索引的 data 域存储相应记录主键的值而不是地址，这也是和 MyISAM 不同的地方。在根据主索引搜索时，直接找到 key 所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，在走一遍主索引。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。

## MySQL 中的 utf8mb3、utf8mb4

`utf8` 是一种变长的编码方式，它可以使用1~4个字节来表示一个 `Unicode` 字符。

MySQL 的 `utf8` 并不是真正概念里的 `UTF-8`。MySQL 中的 `utf8` 编码只支持最大 3 字节每字符。但是 `unicode6` 系列编码上，它们需要 4 个字节，这部分就是 `emoji` 表情。所以，如果数据库使用默认字符设置，是无法存储 `emoji` 表情的。MySQL 的开发者并没有修复这个 bug，而是推出新的字符集 `utf8mb4`。

MySQL 在 5.5.3 之后增加了 `utf8mb4` 的编码，`mb4` 就是 `most bytes 4` 的意思，专门用来兼容四字节的 `Unicode`。因此可以用来存储 `emoji` 表情。

从 8.0 后，MySQL 也将会在某个版本中开始使用 `utf8mb4` 作为默认的字符编码。
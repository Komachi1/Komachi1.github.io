# MyBatis

## 使用分页插件pagehelper

### 一、添加 Maven 依赖

```xml
<dependency>
    <groupId>com.github.pagehelper</groupId>
    <artifactId>pagehelper-spring-boot-starter</artifactId>
    <version>xxx</version>
</dependency>
```

### 二、配置

`pagehelper.helper-dialect` ：指定分页插件使用哪种语言。

`pagehelper.offset-as-page-num` ：默认为 `false`, 该参数对使用 `RowBounds` 作为分页参数时有效，当为 `true` 时，会将 `RowBounds` 的 `offset` 参数当成 `pageNum` 使用。

`pagehelper.row-bounds-with-count` ： 默认为 `false`，该参数对使用 `RowBounds` 作为分页参数时有效，当该参数值为 `true` 时，使用 `RowBounds` 分页会进行 `count` 查询。

`pagehelper.page-size-zero` ：默认为 `false` ，当该参数为 `true` 时，如果 `pageSize=0` 或者 `RowBounds.limit=0` 就会查询所有结果。

`pagehelper.reasonable` ：分页合理化参数，默认为 `false`，当该值为 `true`，`pageNum<=0` 默认查询第一页，`pageNum>pages` 时会查询最后一页，`false` 时直接根据参数进行查询。

`pagehelper.params` ：为了支持 `startPage(Object params)` 方法，增加该参数来配置参数映射，用于从对象中根据属性名取值，可以配置`pageNum`，`pageSize`，`pageSizeZero`，`reasonable`。不配置时的默认值为`pageNum=pageNum`，`pageSize=pageSize`，`count=countSql`，`reasonable=reasonable`，`pageSizeZero=pageSizeZero`。

`pagehelper.support-methods-arguments` ：支持通过 `Mapper` 接口参数来传递分页参数，默认为 `false`, 分页插件会从查询方法的参数中根据 `params` 配置的字段中取值，查找到合适的就进行分页。

`pagehelper.auto-runtime-dialect` ：默认为 `false`, 为 `true` 时允许在运行时根据多数据源自动识别对应的方言进行分页。

`pagehelper.close-conn` : 默认为 `true`, 当使用运行是动态数据源或者没有设置 `helperDialect` 属性自动获取数据库类型时，会自动获取一个数据库连接，通过该属性来设置是否关闭获取的这个连接，默认为 `true` 关闭，`false` 不会自动关闭。

### 三、编写 Service 接口

```java
/**
  * @param currentPage 当前页码
  * @param pageSize 一页的记录数
  * @return
  */
public PageResult<Employee> page(int currentPage, int pageSize) {
        Page<Employee> employeePage = PageHelper.startPage(currentPage,pageSize)
                .doSelectPage(() -> empMapper.getAll());
        return new PageResult<>(employeePage);
    }
```

使用 `PageHelper` 查询得到的 `Page` 对象有以下方法：

```java
// 获取当前的页码
int getPageNum()
// 获取总页数
int getPages()
// 获取总记录数
long getTotal()
// 获取当前页的记录集合
List<E> getResult()
```

# Redis

## 数据类型

**Redis 支持五种数据类型：String（字符串），List（列表），Set（集合），Hash（哈希），及  Zset（Sorted Set有序集合）**。

**String(字符串)：**`String` 是 Redis 最基本的类型。`String` 类型是二进制安全的，因此 Redis 的 `String` 可以包含任何数据，比如 `.jpg` 图片或者序列化的对象。

`String` 的数据结构为简单动态字符串(*Simple Dynamic String*)。是可以修改的字符串，内部结构类似于 Java 中的 `ArrayList`，采用预分配冗余空间的方式来减少内存的频繁分配。为当前字符串实际分配的空间一般要高于实际字符串长度。当字符串长度小于 `1M` 时，扩容都是加倍现有的空间，如果超过 `1M`，扩容时一次只会多扩 `1M` 的空间，字符串最大长度为` 512M`。

一般常用在需要计数的场景，比如用户的访问次数、热点文章的点赞转发数量等等。

**List(列表)：**Redis 的 `List` 的实现为一个双向链表。

**Set(集合)：**Redis 的 `Set` 是一个无序集合。底层为一个值为 `NULL` 的哈希表。可以基于 `Set` 轻易实现交集、并集、差集的操作。

**Hash(哈希)：**Redis 的 `Hash` 的底层是一个 `String` 类型的 `field` 和 `value` 的映射表，`Hash` 特别适合用于存储对象。

**Zset(有序集合)：**Redis 的 `Zset` 是一个有序集合，每成员都会关联一个分数(*score*)，Redis 通过分数来为集合中的成员进行从小到大的排序。`Zset` 的成员是唯一的，但分数可以重复。

`Zset` 底层使用了两种数据结构：

（1）`Hash`，`Hash` 的作用就是关联成员 `member` 和分数 `score`，保证成员 `member` 的唯一性，可以通过成员 `member` 找到相应的 `score` 。

（2）跳跃表，跳跃表的目的在于给成员 `member` 排序，根据 `score` 的范围获取成员列表。

## 发布/订阅

```shell
# 订阅给定的一个或多个频道的信息
> SUBSCRIBE channel1 [channel2 ...]
# 退订给定的频道，若没有频道被指定，则退订订阅的所有频道
> UNSUBSCRIBE [channel1 [channel2 ...]]
# 将信息推送到指定的频道
> PUBLISH channel message
```

## 事务

```shell
# 标记一个事务块的开始
> MULTI
# 执行所有事务块内的命令
> EXEC
# 取消事务，放弃执行事务块内的所有命令
> DISCARD
# 监视一个(或多个)key，如果在事务执行之前这个(或这些)key被其他命令所改动，那么事务将被打断
> WATCH key1 [key2 ...]
# 取消WATCH命令对所有key的监视
> UNWATCH
```

从输入 `MULTI` 命令开始，输入的命令都会依次进入命令队列中，但不会执行，直到输入 `EXEC` 后，Redis 才会将之前的命令队列中的命令依次执行。

组队的过程中可以通过 `DISCARD` 来放弃组队。

### 事务特性

#### **没有隔离级别**

当事务开启时，事务期间的命令并没有执行，而是加入队列。只有执行 `exec` 命令时，事务中的命令才会按照顺序一一执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。从而事务间就不会导致数据脏读、不可重复读、幻读，自然也就没有隔离级别。

#### **不保证原子性**

单个 Redis 命令的执行是原子性的，但 Redis 事务的执行并不是原子性的，Redis 没有在事务上增加任何维持原子性的机制。事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不执行。

### **事务的错误处理**

组队中某个命令出现了错误，执行时队列中所有的命令都不会被执行：

```shell
> MULTI
OK
> SET k1 v1
QUEUED
> SET k2
(error) ERR wrong number of arguments for 'set' command
> EXEC
(error) EXECABORT Transaction discarded because of previous errors.
```

如果执行阶段某个命令出现错误，则只有报错的命令不会被执行，而其他的命令都会执行，不会回滚：

```shell
> MULTI
OK
> SET k1 v1
QUEUED
> INCR k1
QUEUED
> E
1) OK
2) (error) ERR value is not an integer or out of range
```

## 持久化

Redis 提供了两种持久化方案：

* **RDB(*Redis DataBase*)** 持久化可以在指定的时间间隔内生成数据集的时间点快照(*point-in-time snapshot*)。
* **AOF(*Append Only File*)** 持久化记录服务器执行的所有写操作命令，并在服务器启动时，通过重新执行这些命令来还原数据集。AOF 文件中的命令全部以 Redis 协议的格式来保存，新命令会被追加到文件的末尾。 Redis 还可以在后台对 AOF 文件进行重写(*rewrite*)，使得 AOF 文件的体积不会超出保存数据集状态所需的实际大小。

### RDB快照

默认情况下，Redis 保存数据集快照到磁盘，名为 `dump.rdb` 的二进制文件。可以设置让Redis在 N 秒内至少有 M 次数据集改动时保存数据集，或者也可以手动调用 `SAVE` 或者 `BGSAVE` 命令。这种策略被称为快照。

快照的运作方式:

当 Redis 需要保存 `dump.rdb` 文件时， 服务器执行以下操作：

1、Redis 调用 `fork()` 创建子进程；

2、子进程将数据集写入到一个临时 RDB 文件中；

3、当子进程完成对新 RDB 文件的写入时，Redis 用新 RDB 文件替换原来的 RDB 文件，并删除旧的 RDB 文件；

这种工作方式使得 Redis 可以从写时复制(*copy-on-write*)机制中获益。

## 应用问题解决

[Redis缓存击穿、穿透、雪崩解决方案 - 简书 (jianshu.com)](https://www.jianshu.com/p/b7f822935e28)

### 缓存穿透

一般缓存处理流程：

<img src="D:\file\Documents\编程\img\缓存处理流程.png" style="zoom: 40%;" />

当缓存与数据库中都不存在该数据时，由于当数据库查询不到数据就不会写入缓存，这个时候如果用户不断的恶意发起请求，就会导致这个不存在的数据每次请求都会查询 DB，请求量大的情况下，就会导致 DB 压力过大，直接崩溃。

**解决方案**

**1、对空值缓存：**如果一个查询返回的数据为空（不管是数据是否不存在），我们仍然把这个空结果(NULL)进行缓存，过期时间不宜设置过长，最长不超过 5 分钟。

**2、采用布隆过滤器：**将所有可能存在数据，分别通过多个哈希函数生成多个哈希值，然后将这些哈希值存到一个足够大的 Bitmaps 中，此时一个一定不存在的数据就会被这个 Bitmaps 拦截，从而减少了数据库的查询压力。

**3、 设置可访问的名单（白名单）：**使用 Bitmaps 类型定义一个可以访问的名单，名单 id 作为 Bitmaps 的偏移量，每次访问和 Bitmaps 里面的 id 进行比较，如果访问 id 不在 Bitmaps 里面，进行拦截，不允许访问。

**4、进行实时监控：**当发现 Redis 的命中率开始急速降低，需要排查访问对象和访问的数据，和运维人员配合，可以设置黑名单限制服务。

### 缓存击穿

某一个数据缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，严重情况下会直接崩溃。

**解决方案**

**1、预先设置热门数据：**在 Redis 高峰访问之前，把一些热门数据提前存入到 Redis 里面，加大这些热门数据 key 的时长。

**2、实时调整：**现场监控哪些数据热门，实时调整 key 的过期时长。

**3、使用排他锁：**

<img src="D:\file\Documents\编程\img\排他锁解决缓存穿透.png" style="zoom:50%;" />

### 缓存雪崩

缓存中大批量的数据都到了过期时间，从而导致查询数据量巨大，引起数据库压力过大甚至崩溃。

**解决方案**

**1、构建多级缓存架构：**Nginx 缓存 + Redis 缓存 + 其他缓存（Ehcache等）。

**2、使用锁或队列：**用加锁或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。

**3、设置过期标志更新缓存：**记录缓存数据是否过期（设置提前量），如果过期会触发通知另外的线程在后台去更新实际 key 的缓存。

**4、将缓存失效时间分散开：**可以在原有的失效时间基础上增加一个随机值，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。

## 常用命令

在终端启动 Redis 客户端：

```shell
$ redis-cli
```

在远程服务器上执行命令：

```shell
$ redis-cli -h host -p port -a password
```

检测 Redis 服务是否启动：

```shell
> PING
PONG # 输出PONG表明服务已启动
```

查看 Redis 信息：

```shell
> INFO
```

### 库操作

```shell
# 切换到index号数据库
> SELECT <index>	
# 查看当前数据库的key的数量
> DBSIZE	
# 清空当前库
> FLUSHDB
# 清空所有库
> FLUSHALL
```

### key 操作

```shell
# 查看当前库中所有key
> KEYS *
# 判断某个key是否存在
> EXISTS <key>
# 查看指定key的类型
> TYPE <key>
# 删除指定的key 	
> DEL <key>		
# 为指定key设置过期时间
> EXPIRE <key> <seconds>
# 查看key过期剩余时间，-1表示永不过期，-2表示已过期
> TTL <key>
```

### String 操作

```shell
# 添加键值对，如果key已存在，会覆盖原value
> SET <key> <value> [可选参数]
```

可选参数：

* `NX`	只有当数据库中 `key` 不存在时，添加键值对
* `XX`    只有当数据库中 `key` 存在时，添加键值对，与 `NX` 互斥
* `EX <seconds>`    `key` 的过期时间，单位：秒
* `PX <seconds>`    `key` 的过期时间，单位：毫秒，与 `EX` 互斥

```shell
# 只有当key不存在时，添加键值对
> SETNX <key> <value>
# 添加键值对的同时，设置过期时间
> SETEX <key> <second> <value>
# 设置新值同时返回旧值
> GETSET <key> <value>
# 查询key对应的value
> GET <key>
# 将value追加到原值的末尾
> APPEND <key> <value>
# 获得key对应value的长度
> STRLEN <key>
# 将key对应value的数字值加1，只能对数字值操作，如果为空，新增值为1
> INCR <key>
# 将key对应value的数字值减1，只能对数字值操作，如果为空，新增值为-1
> DECR <key>
# 增/减key对应value的数字值，自定义增量
> INCRBY/DECRBY <key> <increment>
# 同时设置一个或多个键值对
> MSET <key1> <value1> <key2> <value2> ...
# 同时获取一个或多个value
> MGET <key1> <key2> <key3> ...
# 同时设置一个或多个键值对，当且仅当所有给定的key都不存在
> MSETNX <key1> <value1> <key2> <value2>
# 获取范围内的value，索引从0开始
> GETRANGE <key> <start> <end>
# 从起始位置开始，用value覆写key所储存的字符串值
> SETRANGE <key> <offset> <value>	
```

### List 操作

```shell
# 从左边/右边插入一个或多个value
> LPUSH/RPUSH <key> <value1> <value2> ...
# 在pivot的前面/后面插入value
> LINSERT <key> BEFORE/AFTER <pivot> <vlaue>
# 覆盖列表key的索引为index的value
> LSET <key> <index> <value>
# 从左边/右边弹出一个value，value为空时key会被清除
> LPOP/RPOP <key>
# 从key1列表右边弹出一个值，插入到key2列表左边
> RPOPLPUSH <key1> <key2>
# 从左边删除n个value（从左到右）
> LREM <key> <n> <value>
# 按照索引下标获得元素（从左到右），0 表示左边第一个，-1表示右边第一个（0 -1表示获取所有）
> LRANGE<key> <start> <stop>
# 按照索引下标获得元素（从左到右）
> LINDEX <key> <index>
# 获得列表长度
> LLEN <key>
```

### Set 操作

```shell
# 将一个或多个member加入到集合key中，已经存在的member将被忽略
> SADD <key> <member1> <member2> ...
# 取出该集合的所有member
> SMEMBERS <key>
# 判断集合key是否为含有该member，有返回1，没有返回0
> SISMEMBER <key> <member>
# 返回该集合的member个数
> CARD <key>
# 删除集合中的一个或多个member
> SREM <key> <member1> <member2> ...
# 随机从集合弹出一个member
> SPOP <key>
# 随机从集合中取出n个member，这些member不会从集合中删除
> SRANDMEMBER <key> <n>
# 把集合中一个member从一个集合移动到另一个集合
> SMOVE <source> <destination> <member> 
# 返回两个集合的交集
> SINTER <key1> <key2>
# 返回两个集合的并集
> SUNION <key1> <key2>
# 返回两个集合的差集
> SDIFF <key1> <key2>
```

### Hash 操作

```shell
# 给hash中的field赋值value
> HSET <key> <field> <value>
# 从hash中的field取出value
> HGET <key> <field>
# 批量设置hash
> HMSET <key1> <field1> <value1> <field2> <value2> ...
# 查看hash中field是否存在
> HEXISTS <key> <field>
# 查看hash中的所有field
> HKEYS <key>
# 查看hash中的所有value
> HVALS <key>
# 为hash中的field的值加上自定义增量
> HINCRBY <key> <field> <increment>
# 当且仅当field不存在时，设置hash中的field的value
> HSETNX <key> <field> <value>	
```

### Zset 操作

```shell
# 将一个或多个member和对应score加入到有序集key中
> ZADD <key> <score1> <member1> <score2> <member2> ...
# 获取有序集key中指定范围的member,WITHSCORES表示让score和member一同返回
> ZRANGE <key> <start> <stop> [WITHSCORES]
# 返回有序集key中，所有score介于min和max之间（包括等于）的value。有序集成员按score值递增（从小到大）次序排列 
> ZRANGEBYSCORE <key> <min> <max> [WITHSCORES] [LIMIT offset count]
# 同上，排列顺序为从大到小 
> ZREVRANGEBYSCORE <key> <max> <min> [WITHSCORES] [LIMIT offset count] 
# 为member的score加上增量
> ZINCRBY <key> <increment> <value>
# 删除集合中的member
> ZREM <key> <member> 	
# 统计该集合score区间内的member个数
> ZCOUNT <key> <min> <max>
# 返回member在集合中的排名，从0开始
> ZRANK <key> <member>	
```

## Q&A

### Redis除了缓存，还可以做哪些事？

1. **排行榜**，如果使用传统的关系型数据库来做，非常麻烦，而利用 Redis 的 `Zset` 数据结构能够非常方便搞定。
2. **计算器/限速器**，利用 Redis 中原子性的自增操作，我们可以统计类似用户点赞数、用户访问数等，这类操作如果用 MySQL，频繁的读写会带来相当大的压力；限速器比较典型的使用场景是限制某个用户访问某个 API 的频率，常用的有抢购时，防止用户疯狂点击带来不必要的压力。
3. **好友关系**，利用集合的一些命令，比如求交集、并集、差集等，可以方便搞定一些共同好友、共同爱好之类的功能。
4. **简单消息队列**，除了 Redis 自身的发布/订阅模式，我们也可以利用 List 来实现一个队列机制，比如到货通知、邮件发送之类的需求，不需要高可靠，但是会带来非常大的 DB 压力，完全可以用 list 来完成异步解耦。
5. **Session 共享**，以 PHP 为例，默认 Session 是保存在服务器的文件中，如果是集群服务，同一个用户过来可能落在不同机器上，这就会导致用户频繁登陆；采用 Redis 保存 Session 后，无论用户落在那台机器上都能够获取到对应的 Session 信息。

### Redis不能做哪些事？

1. 用 Redis 去保存用户的基本信息，虽然它能够支持持久化，但是它的持久化方案并不能保证数据绝对的落地，并且还可能带来 Redis 性能下降，因为持久化太过频繁会增大 Redis 服务的压力。
2. 数据量太大、数据访问频率非常低的业务都不适合使用 Redis，数据太大会增加成本，访问频率太低，保存在内存中纯属浪费资源。

### Redis为什么这么快？

1、Redis 是一款纯内存结构，避免了磁盘 I/O 等耗时操作。

2、Redis 命令处理的核心模块为单线程，减少了锁竞争，以及频繁创建线程和销毁线程的代价，减少了线程上下文切换的消耗。

3、采用了 I/O 多路复用机制，大大提升了并发效率。

### Redis是单线程还是多线程？

Redis 基于 Reactor 模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器(*file event handler*)。文件事件处理器是单线程方式运行的，所以一般都说 Redis 是单线程模型。

文件事件处理器使用 I/O 多路复用程序来同时监听多个套接字(*socket*)，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。当被监听的套接字准备好执行连接应答(accept)、读取(read)、写入(write)、关闭(close)等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。

 I/O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗（和 NIO 中的 `Selector` 组件很像）。

虽然文件事件处理器以单线程方式运行，但通过使用 I/O 多路复用程序来监听多个套接字，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与 Redis 服务器中其他同样以单线程方式运行的模块进行对接，这保持了 Redis 内部单线程设计的简单性。

### Redis的过期键的删除策略

[Redis过期键删除策略 - 简书 (jianshu.com)](https://www.jianshu.com/p/406edc497d75)

#### 保存键过期时间

redisDb 结果的 expires 字典保存了数据库中所有键的过期时间，我们称这个字典为过期字典

- 过期字典的键是一个指针，这个指针指向键空间的某个键对象
- 过期字典的值是一个 long long 类型的证书，用于保存毫秒精度的 UNIX 时间戳

#### 定时删除

 在设置键的过期时间的同时，创建一个定时器，让定时器执行对键的删除操作。

定时删除策略对内存最友好，通过使用定时器，定时删除策略可以保证键在过期时间一定会被删除，删除后就释放该键之前占用的内存。但是，定时删除策略的缺点是，它对 CPU 时间是最不友好的，在过期键比较多的情况下，删除过期键这一行为可能会占用相当一部分 CPU 时间，在内存不紧张但是 CPU 时间非常紧张的情况下，将大量 CPU 时间浪费在删除过期的策略上，而不是用在处理客户端的请求上，毫无疑问是不行的。

#### 惰性删除

每次取的时候先判断 expires 对象里面的键是否已经过期，如果过期，则删除键，否则，返回该键。

通过定时删除的描述，你可能会想那用惰性删除就最好了，这样就不会浪费 CPU 时间，每次取数据的时候才判断，如果过期才删除它，这样就能腾出大量的 CPU 去处理客户端请求了。然而，这对内存却又是最不友好的，因为这种策略并不能保证所有键一定会访问到，比如说一些取得并不频繁的数据，就会大量堆积在内存中，如果这些内存得不到释放，可想而知后果是多么严重。

#### 定期删除

 每隔一段时间，程序对数据库遍历检查一遍，然后删除过期的键。

定期策略每隔一段时间执行一次删除过期的操作，并通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。定期删除过期键能有效的减少过期键而造成的内存浪费，但是，这个问题点在于如何设定删除操作执行的时长和频率？设置的太频繁吧，就又跟定时删除一样，浪费大量 CPU，设置得长一点吧，这又可能出现内存大量堆积。

#### Redis所使用的过期删除策略

Redis实际上使用的是惰性删除和定期删除两种策略，通过配合使用，服务器可以很好的平衡 CPU 和内存。

**惰性删除策略的实现**

每次取数据的时候都会调用过滤函数(db.c/expireIfNeeded)，该函数主要用来判断键是否

过期，如果过期，则删除键，否则，则取得对应键的值。

**定期删除键的策略实现**

过期键的定期删除策略由 `redis.c/activeExpireCycle` 函数实现，每当 Redis 的服务器周期性操作 `redis.c/serverCron` 函数执行时， `activeExpireCycle` 函数就会被调用，它在规定的时间内分多次遍历服务器的各个数据库，检查数据库的 expires 字典中部分键(相当于分页查询)的过期时间，并删除它。步骤如下：

- 函数每次运行时，都从一定数量的数据库取出一定数量的随机键进行检查，并删除其中的过期键。
- 全局变量 `current_db` 会记录当前 `activeExpireCycle` 函数的检查进度，并在下一次 `activeExpireCycle` 调用时，接着上一次的进度进行处理。
- 随着 `activeExpireCycle` 函数的不断执行，服务器中的所有数据库都会被检查一遍，当到达最后时，把 `current_db` 设置为 0，然后又重新开始，如此循环下去。

